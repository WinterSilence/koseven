<?php

/**
 * Contains the most low-level helpers methods in framework:
 * - Environment initialization
 * - Locating files within the cascading filesystem
 * - Auto-loading and transparent extension of classes
 * - Variable and path debugging
 *
 * @package KO7
 * @category Base
 * @copyright (c) 2007-2016  Kohana Team
 * @copyright (c) 2016-2020 KO7 team
 * @license BSD-3-Clause
 */
abstract class KO7_Core
{
    /**
     * @var int Release version
     */
    public const VERSION = '4.0.0';
    
    /**
     * @var int Production environment
     */
    public const PRODUCTION = 10;
    
    /**
     * @var int Staging environment
     */
    public const STAGING = 20;
    
    /**
     * @var int Testing environment
     */
    public const TESTING = 30;
    
    /**
     * @var int Development environment
     */
    public const DEVELOPMENT = 40;
    
    /**
     * @var int Current environment.
     */
    public static $environment = self::DEVELOPMENT;
    
    /**
     * @var bool Run framework with backwards compatibility module "kohana".
     */
    public static $compatibility = true;
    
    /**
     * @var bool True if framework is running on OS Windows
     */
    public static $is_windows = DIRECTORY_SEPARATOR !== '/';
    
    /**
     * @var string Content type of HTTP response.
     */
    public static $content_type = 'text/html';
    
    /**
     * @var string Character set of input and output.
     */
    public static $charset = 'utf-8';
    
    /**
     * @var string The name of the server is hosted upon.
     */
    public static $server_name = '';
    
    /**
     * @var string[] list of valid host names for this instance.
     */
    public static $hostnames = [];
    
    /**
     * @var string base URL to the application.
     */
    public static $base_url = '/';
    
    /**
     * @var string Application index file, added to links generated by framework.
     */
    public static $index_file = 'index.php';
    
    /**
     * @var string Directory of system cache.
     */
    public static $cache_dir = APPPATH . 'cache';
    
    /**
     * @var int Cache life time in seconds.
     */
    public static $cache_life = 180;
    
    /**
     * @var bool Whether to use caching.
     */
    public static $caching = false;
    
    /**
     * @var bool Whether to enable [profiling](system/profiling).
     */
    public static $profiling = true;
    
    /**
     * @var bool Enable framework catching and displaying PHP errors and exceptions.
     */
    public static $errors = true;
    
    /**
     * @var int[] Types of errors to display at shutdown.
     */
    public static $shutdown_errors = [E_PARSE, E_ERROR, E_USER_ERROR];
    
    /**
     * @var bool Set the 'X-Powered-By' header?
     */
    public static $expose = false;
    
    /**
     * @var Log Logging instance.
     */
    public static $log;
    
    /**
     * @var Config Configuration instance
     */
    public static $config;
    
    /**
     * @var bool Has `static::init()` been called?
     */
    protected static $init = false;
    
    /**
     * @var string[] Currently active modules
     */
    protected static $modules = [];
    
    /**
     * @var string[] Include paths that are used to find files
     */
    protected static $paths = [APPPATH, SYSPATH];
    
    /**
     * @var array File path cache, used when caching is true in `static::init()`.
     */
    protected static $files = [];
    
    /**
     * @var bool Has the file path cache changed during execution? Used internally when caching in `static::init()`.
     */
    protected static $files_changed = false;
    
    /**
     * Initializes the environment:
     * - Determines the current environment
     * - Set global settings
     * - Sanitizes GET, POST, and COOKIE variables
     * - Converts GET, POST, and COOKIE variables to the global character set
     * The following settings can be set:
     * Type      | Setting    | Description                                    | Default Value
     * ----------|------------|------------------------------------------------|---------------
     * `string`  | `base_url`   | The base URL for your application.  This should be the *relative* path from your
     * DOCROOT to your `index.php` file, in other words, if KO7 is in a subfolder, set this to the subfolder name,
     * otherwise leave it as the default.  **The leading slash is required**, trailing slash is optional.   | `"/"`
     * `string`  | `index_file` | The name of the [front
     * controller](http://en.wikipedia.org/wiki/Front_Controller_pattern).  This is used by KO7 to generate relative
     * urls like [HTML::anchor()] and [URL::base()]. This is usually `index.php`.  To [remove index.php from your
     * urls](tutorials/clean-urls), set this to `FALSE`. | `"index.php"`
     * `string`  | `charset`    | Character set used for input and output    | `"utf-8"`
     * `string`  | `cache_dir`  | Cache directory  | `APPPATH."cache"`
     * `integer` | `cache_life` | Lifetime, in seconds, of items cached by [static::cache]         | `180`
     * `bool` | `errors`     | Should KO7 catch PHP errors and uncaught Exceptions and show the `error_view`. See
     * [error handling](system/errors) for more info. Recommended setting: `true` while developing, `false`
     * on production servers. | `TRUE`
     * `bool` | `profiling`  | Whether to enable the [Profiler](system/profiling). Recommended setting:
     * `TRUE` while developing, `FALSE` on production servers. | `TRUE`
     * `bool` | `caching`    | Cache file locations to speed up [static::find_file].  This has nothing to do with
     * `static::cache()`, [fragments](system/fragments) or the [caching](cache/about). Recommended setting:
     * `FALSE` while developing, `TRUE` on production servers. | `FALSE`
     * `bool` | `expose`     | Set the X-Powered-By header
     *
     * @param array $settings An array of settings.
     * @return void
     * @throws KO7_Exception
     */
    public static function init(array $settings = []): void
    {
        if (static::$init) {
            // Don't allow execution twice.
            return;
        }
        
        // Framework is now initialized.
        static::$init = true;
        
        if (isset($settings['profiling'])) {
            static::$profiling = (bool) $settings['profiling'];
        }
        
        if (isset($settings['errors'])) {
            // Set error handling
            static::$errors = (bool) $settings['errors'];
        }
        
        // Start an output buffer
        ob_start();
        
        if (static::$errors) {
            // Enable framework's exception handling, adds stack traces and error source.
            set_exception_handler(['KO7_Exception', 'handler']);
            // Enable framework's  error handling, converts all PHP errors to exceptions.
            set_error_handler([static::class, 'error_handler']);
        }
        
        // Enable xDebug parameter collection in development mode to improve fatal stack traces.
        if (static::$environment === static::DEVELOPMENT && extension_loaded('xdebug')) {
            ini_set('xdebug.collect_params', 3);
        }
        
        // Enable the framework's shutdown handler, which catches E_FATAL errors.
        register_shutdown_function([static::class, 'shutdown_handler']);
        
        if (isset($settings['expose'])) {
            static::$expose = (bool) $settings['expose'];
        }
        
        if (isset($settings['cache_dir'])) {
            if (! is_dir($settings['cache_dir'])) {
                // Create the cache directory
                if (! mkdir($settings['cache_dir'], 0755, true) || ! is_dir($settings['cache_dir'])) {
                    throw new KO7_Exception(
                        'Could not create cache directory :dir',
                        [':dir' => Debug::path($settings['cache_dir'])]
                    );
                }
                // Set permissions (must be manually set to fix umask issues)
                chmod($settings['cache_dir'], 0755);
            }
            // Set the cache directory path
            static::$cache_dir = realpath($settings['cache_dir']);
        }
        
        if (! is_writable(static::$cache_dir)) {
            throw new KO7_Exception(
                'Cache directory :dir must be writable.',
                [':dir' => Debug::path(static::$cache_dir)]
            );
        }
        
        if (isset($settings['cache_life'])) {
            // Set the default cache lifetime
            static::$cache_life = (int) $settings['cache_life'];
        }
        
        if (isset($settings['caching'])) {
            // Enable or disable internal caching
            static::$caching = (bool) $settings['caching'];
        }
        
        if (static::$caching) {
            // Load the file path cache
            static::$files = static::cache('KO7::find_file()');
        }
        
        if (isset($settings['charset'])) {
            // Set the system character set
            static::$charset = strtolower($settings['charset']);
        }
        
        if (function_exists('mb_internal_encoding')) {
            // Set the MB extension encoding to the same character set
            mb_internal_encoding(static::$charset);
        }
        
        if (isset($settings['base_url'])) {
            // Set the base URL
            static::$base_url = rtrim($settings['base_url'], '/') . '/';
        }
        
        if (isset($settings['index_file'])) {
            // Set the index file
            static::$index_file = ltrim($settings['index_file'], '/');
        }
        
        // @todo move to server Request and Cookie classes
        // Sanitize all request variables
        if (isset($_GET)) {
            $_GET = filter_input(INPUT_GET, FILTER_CALLBACK, ['options' => [static::class, 'sanitize']]);
        }
        if (isset($_POST)) {
            $_POST = filter_input(INPUT_POST, FILTER_CALLBACK, ['options' => [static::class, 'sanitize']]);
        }
        if (isset($_COOKIE)) {
            $_COOKIE = filter_input(INPUT_COOKIE, FILTER_CALLBACK, ['options' => [static::class, 'sanitize']]);
        }
        
        // @todo dependency injection
        // Load the logger if one doesn't already exist
        if (! static::$log instanceof Log) {
            static::$log = new Log();
        }
        // Load the config if one doesn't already exist
        if (! static::$config instanceof Config) {
            static::$config = new Config();
        }
    }
    
    /**
     * Cache variables using current cache module if enabled, if not uses `static::file_cache()`.
     *
     * @param string $name name of the cache
     * @param mixed $data data to cache
     * @param int|null $lifetime number of seconds the cache is valid for
     * @return mixed
     * @throws KO7_Exception
     * @todo Cache interface + dependency injection
     */
    public static function cache(string $name, $data = null, int $lifetime = null)
    {
        // in case the cache module is not yet loaded we need to use the normal cache, sucks but happens onload
        if (class_exists('Cache')) {
            // deletes the cache
            if ($lifetime <= 0) {
                return Cache::instance()->delete($name);
            }
            //no data provided we read
            if ($data === null) {
                return Cache::instance()->get($name);
            }
            //saves data
            return Cache::instance()->set($name, $data, $lifetime);
        }
        return static::file_cache($name, $data, $lifetime);
    }
    
    /**
     * Provides simple file-based caching for strings and arrays. All caches are stored as PHP code, generated with
     * `var_export()`. Caching objects may not work as expected. Storing references or an object or array that has
     * recursion will cause an `E_FATAL`. The cache directory and default cache lifetime is set by `static::init()`.
     *
     * @param string $name name of the cache
     * @param mixed $data data to cache
     * @param int|null $lifetime number of seconds the cache is valid for
     * @return mixed
     * @throws KO7_Exception
     * @todo remove at update `static::cache()`
     */
    public static function file_cache(string $name, $data = null, int $lifetime = null)
    {
        // Cache file is a hash of the name
        $file = sha1($name) . '.txt';
        // Cache directories are split by keys to prevent filesystem overload
        $dir = static::$cache_dir . DIRECTORY_SEPARATOR . $file[0] . $file[1] . DIRECTORY_SEPARATOR;
        if ($lifetime === null) {
            // Use the default lifetime
            $lifetime = static::$cache_life;
        }
        if ($data === null) {
            if (is_file($dir . $file)) {
                if ((time() - filemtime($dir . $file)) < $lifetime) {
                    // Return the cache
                    try {
                        return unserialize(file_get_contents($dir . $file), false);
                    } catch (Throwable $e) {
                        // Cache is corrupt, let return happen normally.
                    }
                } else {
                    try {
                        // Cache has expired
                        unlink($dir . $file);
                    } catch (Throwable $e) {
                        // Cache has mostly likely already been deleted, let return happen normally.
                    }
                }
            }
            // Cache not found
            return null;
        }
        if (! is_dir($dir)) {
            // Create the cache directory
            if (! mkdir($dir, 0755, true) || ! is_dir($dir)) {
                throw new KO7_Exception('Cache directory ":dir" was not created', [':dir' => $dir]);
            }
            // Set permissions (must be manually set to fix umask issues)
            chmod($dir, 0755);
        }
        // Force the data to be a string
        $data = serialize($data);
        // Write the cache
        return file_put_contents($dir . $file, $data, LOCK_EX) !== false;
    }
    
    /**
     * Recursively normalize and sanitize input variables.
     *
     * @param mixed $value any variable
     * @return mixed sanitized variable
     */
    public static function sanitize($value)
    {
        if (is_string($value)) {
            // Standardize newl ines
            return str_replace(["\r\n", "\r"], "\n", $value);
        }
        if (is_iterable($value)) {
            foreach ($value as $key => $val) {
                // Recursively clean each value
                $value[$key] = static::sanitize($val);
            }
        }
        return $value;
    }
    
    /**
     * Cleans up the environment:
     * - Restore the previous error and exception handlers
     * - Destroy the `static::$log` and `static::$config`
     *
     * @return void
     */
    public static function deinit(): void
    {
        if (static::$init) {
            // Removed the autoloader
            spl_autoload_unregister([static::class, 'auto_load']);
            if (static::$errors) {
                // Go back to the previous error handler
                restore_error_handler();
                // Go back to the previous exception handler
                restore_exception_handler();
            }
            // Destroy objects created by init
            static::$log = static::$config = null;
            // Reset internal storage
            static::$modules = static::$files = [];
            static::$paths = [APPPATH, SYSPATH];
            // Reset file cache status
            static::$files_changed = false;
            // KO7 is no longer initialized
            static::$init = false;
        }
    }
    
    /**
     * Provides auto-loading support of classes that follow KO7's [class
     * naming conventions](ko7/conventions#class-names-and-file-location).
     * See [Loading Classes](ko7/autoloading) for more information.
     *     // Loads classes/My/Class/Name.php
     *     static::auto_load('My_Class_Name');
     * or with a custom directory:
     *     // Loads vendor/My/Class/Name.php
     *     static::auto_load('My_Class_Name', 'vendor');
     * You should never have to call this function, as simply calling a class
     * will cause it to be called.
     * This function must be enabled as an autoloader in the bootstrap:
     *     spl_autoload_register(array('KO7', 'auto_load'));
     *
     * @param string $class Class name
     * @param string $directory Directory to load from
     * @return bool
     */
    public static function auto_load(string $class, string $directory = 'classes'): bool
    {
        // Transform the class name according to PSR-0
        $class = ltrim($class, '\\');
        $file = '';
        $last_namespace_position = strrpos($class, '\\');
        if ($last_namespace_position) {
            $class = substr($class, $last_namespace_position + 1);
            $namespace = substr($class, 0, $last_namespace_position);
            $file = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
        }
        $file .= str_replace('_', DIRECTORY_SEPARATOR, $class);
        $path = static::find_file($directory, $file);
        if ($path) {
            require_once($path);
            // Class has been loaded
            return true;
        }
        // Class is not in the filesystem
        return false;
    }
    
    /**
     * Searches for a file in the [Cascading Filesystem](ko7/files), and
     * returns the path to the file that has the highest precedence, so that it
     * can be included.
     * When searching the "config", "messages", or "i18n" directories, or when
     * the `$array` flag is set to true, an array of all the files that match
     * that path in the [Cascading Filesystem](ko7/files) will be returned.
     * These files will return arrays which must be merged together.
     * If no extension is given, the default extension (`EXT` set in `index.php`) will be used.
     *
     * @param string $dir directory name: 'views', 'i18n', 'classes', extensions, etc.
     * @param string $file filename with subdirectory
     * @param string|null $ext extension to search for
     * @param bool $array return an array of files?
     * @return string|string[] single file path or a list of files when $array is TRUE
     */
    public static function find_file(string $dir, string $file, ?string $ext = EXT, bool $array = false)
    {
        if ($ext === null) {
            // Use the default extension
            $ext = EXT;
        } elseif ($ext) {
            // Prefix the extension with a period
            $ext = '.' . $ext;
        }
        
        // Create a partial path of the filename
        $path = $dir . DIRECTORY_SEPARATOR . $file . $ext;
        $key = $path . ($array ? '_array' : '_path');
        if (static::$caching && isset(static::$files[$key])) {
            // This path has been cached
            return static::$files[$key];
        }
        
        if (static::$profiling) {
            // Start a new benchmark
            $benchmark = Profiler::start(static::class, __FUNCTION__);
        }
        
        if ($array || in_array($dir, ['config', 'i18n', 'messages'], true)) {
            // Array of files that have been found
            $found = [];
            // Paths defined in reverse order
            foreach (array_reverse(static::$paths) as $baseDir) {
                if (is_file($baseDir . $path)) {
                    $found[] = $baseDir . $path;
                }
            }
        } else {
            // The file has not been found yet
            $found = false;
            /**
             * Note: This check is only needed if we are PRE-Initialization and in compatibility mode. Only performing
             * before initialization makes sure that no `strpos()`, etc. operations get called without being necessary.
             */
            if (! static::$init && static::$compatibility && strpos($path, 'kohana') !== false) {
                $found = MODPATH . 'kohana' . DIRECTORY_SEPARATOR . $path;
                if (! is_file($found)) {
                    $found = false;
                }
            }
            // If still not found. Search through $paths
            if (! $found) {
                foreach (static::$paths as $basePath) {
                    if (is_file($basePath . $path)) {
                        // A path has been found
                        $found = $basePath . $path;
                        // Stop searching
                        break;
                    }
                }
            }
        }
        
        if (static::$caching) {
            // Add the path to the cache
            static::$files[$path . ($array ? '_array' : '_path')] = $found;
            // Files have been changed
            static::$files_changed = true;
        }
        
        if (isset($benchmark)) {
            // Stop the benchmark
            Profiler::stop($benchmark);
        }
        
        return $found;
    }
    
    /**
     * Changes the currently enabled modules. Module paths may be relative or absolute, but must point to a directory.
     *
     * @param array|null $modules list of module paths
     * @return array enabled modules
     * @throws KO7_Exception
     */
    public static function modules(array $modules = null): array
    {
        if ($modules === null) {
            // Not changing modules, just return the current set
            return static::$modules;
        }
        
        // Start a new list of include paths, APPPATH first
        $paths = [APPPATH];
        
        foreach ($modules as $name => $path) {
            if (is_dir($path)) {
                // Add the module to include paths
                $paths[] = $modules[$name] = realpath($path) . DIRECTORY_SEPARATOR;
            } else {
                // This module is invalid, remove it
                throw new KO7_Exception(
                    'Attempted to load an invalid or missing module \':module\' at \':path\'',
                    [':module' => $name, ':path' => Debug::path($path)]
                );
            }
        }
        
        // Finish the include paths by adding system path
        $paths[] = SYSPATH;
        
        // Set the new include paths
        static::$paths = $paths;
        
        // Set the current module list
        static::$modules = $modules;
        
        foreach (static::$modules as $path) {
            $init = $path . 'init' . EXT;
            if (is_file($init)) {
                // Include the initialization file of  module
                require_once($init);
            }
        }
        
        return static::$modules;
    }
    
    /**
     * Returns the the currently active include paths, including: application, system and modules paths.
     *
     * @return string[]
     */
    public static function include_paths(): array
    {
        return static::$paths;
    }
    
    /**
     * Recursively finds all of the files in the specified directory at any location in the
     * [cascading filesystem](system/files) and returns an array of all the files found, sorted alphabetically.
     *
     * @param string|null $directory Top directory
     * @param string[] $paths list of paths to search
     * @param string|string[]|null $ext only list files with this extension
     * @param bool $sort sort alphabetically
     * @return string[]
     */
    public static function list_files(
        ?string $directory = null,
        array $paths = [],
        $ext = null,
        bool $sort = false
    ): array {
        if ($directory !== null) {
            // Add the directory separator
            $directory .= DIRECTORY_SEPARATOR;
        }
        
        if ($paths === null) {
            // Use the default paths
            $paths = static::$paths;
        }
        
        if (is_string($ext)) {
            // convert string extension to array
            $ext = [$ext];
        }
        
        if ($sort === null) {
            // sort results by default
            $sort = true;
        }
        
        // Create an array for the files
        $found = [];
        
        foreach ($paths as $path) {
            if (is_dir($path . $directory)) {
                // Create a new directory iterator
                $dir = new FilesystemIterator($path . $directory);
                
                foreach ($dir as $file) {
                    // Get the file name
                    $filename = $file->getFilename();
                    // Skip hidden files and UNIX backup files
                    if (in_array($filename[0], ['.', '$', '_'], true) || substr($filename, -1) === '~') {
                        continue;
                    }
                    
                    // Relative filename is the array key
                    $key = $directory . $filename;
                    
                    if ($file->isDir()) {
                        // Append the sub-directories to list
                        $subdir = static::list_files($key, $paths, $ext, $sort);
                        if ($subdir) {
                            if (! isset($found[$key])) {
                                $found[$key] = [];
                            }
                            $found[$key] += $subdir;
                        }
                    } elseif ($ext === null || in_array('.' . $file->getExtension(), $ext, true)) {
                        if (! isset($found[$key])) {
                            // Add new file to the list
                            $found[$key] = realpath($file->getPathname());
                        }
                    }
                }
            }
        }
        
        if ($sort) {
            // Sort the results alphabetically
            ksort($found);
        }
        
        return $found;
    }
    
    /**
     * Get a message from a file. Messages are arbitrary strings that are stored
     * in the `messages/` directory and reference by a key. Translation is not
     * performed on the returned values.  See [message files](ko7/files/messages)
     * for more information.
     *
     * @param string $file file name
     * @param string|null $path key path to get
     * @param mixed $default default value if the path does not exist
     * @return string|string[] message string for the given path or complete message list, when no path is specified
     */
    public static function message(string $file, ?string $path = null, $default = null)
    {
        static $messages;
        
        if (! isset($messages[$file])) {
            // Create a new message list
            $messages[$file] = [];
            
            if ($files = static::find_file('messages', $file)) {
                foreach ($files as $f) {
                    // Combine all the messages recursively
                    $messages[$file] = Arr::merge($messages[$file], static::load($f));
                }
            }
        }
        
        if ($path === null) {
            // Return all of the messages
            return $messages[$file];
        }
        
        // Get a message using the path
        return Arr::path($messages[$file], $path, $default);
    }
    
    /**
     * Loads a file within a totally empty scope and returns the output:.
     *     $foo = static::load('foo.php');
     *
     * @param string $file
     * @return mixed
     */
    public static function load($file)
    {
        return include $file;
    }
    
    /**
     * PHP error handler, converts all errors into Error_Exceptions. This handler
     * respects error_reporting settings.
     *
     * @param mixed $code
     * @param mixed $error
     * @param null|mixed $file
     * @param null|mixed $line
     * @return TRUE
     * @throws Error_Exception
     */
    public static function error_handler($code, $error, $file = null, $line = null)
    {
        if (error_reporting() & $code) {
            // This error is not suppressed by current error reporting settings
            // Convert the error into an Error_Exception
            throw new Error_Exception($error, null, $code, 0, $file, $line);
        }
        
        // Do not execute the PHP error handler
        return true;
    }
    
    /**
     * Catches errors that are not caught by the error handler, such as `E_PARSE`.
     *
     * @return void
     */
    public static function shutdown_handler(): void
    {
        if (! static::$init) {
            // Do not execute when not active
            return;
        }
        try {
            if (static::$caching === true && static::$files_changed === true) {
                // Write the file path cache
                static::cache('KO7::find_file()', static::$files);
            }
        } catch (Throwable $e) {
            // Pass the exception to the handler
            KO7_Exception::handler($e);
        }
        
        if (static::$errors) {
            $error = error_get_last();
            if ($error && in_array($error['type'], static::$shutdown_errors, true)) {
                // Clean the output buffer
                ob_get_level() && ob_clean();
                // Fake an exception for nice debugging
                KO7_Exception::handler(
                // @todo use self handler
                    new Error_Exception($error['message'], null, $error['type'], 0, $error['file'], $error['line'])
                );
                // Shutdown now to avoid a "death loop"
                exit(1);
            }
        }
    }
    
    /**
     * Generates a version string based on the variables defined above.
     *
     * @return string
     */
    public static function version(): string
    {
        return 'KO7 ' . static::VERSION;
    }
    
    /**
     * Call this within your function to mark it deprecated.
     *
     * @param string $since Version since this function shall be marked deprecated.
     * @param string $replacement [optional] replacement function to use instead
     * @return void
     */
    public static function deprecated(string $since, string $replacement = ''): void
    {
        $calling = debug_backtrace()[1];
        $msg = I18n::get(
            [
                'Method ":class:::method" is deprecated since ver.:since and will be removed in major release.',
                [':class' => $calling['class'], ':method' => $calling['function'], ':since' => $since],
            ]
        );
        if ($replacement) {
            $msg .= ' ' . I18n::get(['Please consider replacing it with ":replace".', [':replace' => $replacement]]);
        }
        // Log the deprecation
        static::$log->add(Log::WARNING, $msg);
        static::$log->write();
    }
}
